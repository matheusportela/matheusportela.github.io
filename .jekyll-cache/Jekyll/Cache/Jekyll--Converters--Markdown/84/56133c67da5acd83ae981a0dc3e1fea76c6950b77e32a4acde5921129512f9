I"Æ<p>Differently from <a href="/python-3-5-0-has-just-been-released/">Python 3.5, which introduced lots of new features to the language</a> the 3.6 release is basically about enhancing performance, fixing bugs and deprecating stuff. Out of those modifications, the most important is the deprecation of <code class="highlighter-rouge">async</code> and <code class="highlighter-rouge">await</code> as variable names, since they will become language keywords due to the new coroutines syntax <a href="https://www.python.org/dev/peps/pep-0492/">as explained in PEP 492</a>.</p>

<p>However, Python 3.6 presents the users one more way to format strings, <a href="https://www.python.org/dev/peps/pep-0498/">defined in PEP 498</a>. This feature is heavily inspired by string interpolation as implemented in other programming languages, such as <a href="https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals#Interpolation">Ruby</a>, <a href="http://perlmeme.org/howtos/using_perl/interpolation.html">Perl</a>, <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_04.html">Shell Script</a>, <a href="http://docs.scala-lang.org/overviews/core/string-interpolation.html">Scala</a>, and <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID292">Swift</a>, and tries to do easier string formatting. But what‚Äôs wrong with our current methods?</p>

<p>First, the old <code class="highlighter-rouge">%</code>-formatting supports only a limited number of types: integers, strings, and floats. Any other type must be casted to string to become valid. This casting presents a well-known problem when the only argument to be formatted is a tuple, since <code class="highlighter-rouge">%</code>-formatting uses brackets in its own syntax.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">'disk failure'</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s">'error: </span><span class="si">%</span><span class="s">s'</span> <span class="o">%</span> <span class="n">msg</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="ow">not</span> <span class="nb">all</span> <span class="n">arguments</span> <span class="n">converted</span> <span class="n">during</span> <span class="n">string</span> <span class="n">formatting</span></code></pre></figure>

<p>Trying to solve some of these problems, <code class="highlighter-rouge">str.format()</code> provided string formatting with usual method call syntax, as well as better support for custom types, <a href="https://www.python.org/dev/peps/pep-3101/">as detailed in PEP 3101</a>. However, this came with the cost of verbosity and boilerplate code, specially for simple scenarios that were supposed to as small and easy as a ‚Äúhello, world!‚Äù.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s">'The value is {}.'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="s">'The value is 80.'</span></code></pre></figure>

<p>In Python 3.6, we can now benefit com <code class="highlighter-rouge">f</code>-strings and its string interpolation magics. For instance, the previous example would simply become the following. Note that the only requirement is to precede the string with an <code class="highlighter-rouge">f</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="s">'The value is {value}.'</span>
<span class="s">'The value is 80.'</span></code></pre></figure>

<p>In fact, it supports even more advanced tricks, such as accessing variable attributes directly, combining with raw strings to create regular expressions, for instance, and even parsing results from lambda expressions.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1991</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="s">'{date} was on a {date:</span><span class="si">%</span><span class="s">A}'</span>
<span class="s">'1991-10-12 was on a Saturday'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fr</span><span class="s">'{date}: </span><span class="err">\</span><span class="s">s+'</span>
<span class="s">'1991-10-12 </span><span class="se">\\</span><span class="s">s+'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="s">'{(lambda x: x*2)(3)}'</span>
<span class="s">'6'</span></code></pre></figure>

<p>That‚Äôs it. What are your thoughts on <code class="highlighter-rouge">f</code>-strings? Will you replace your preferred string formatting method by this one?</p>
:ET