I""<p>Last Sunday, the <a href="https://www.python.org/downloads/release/python-350/">Python Software Foundation released the last update for the Python language</a>. This afternoon, I finally had time to read the PEPs corresponding to the major new features and some of them are really exciting. Check out my compilation of nice features that Python 3.5.0 provides.</p>

<h2 id="-formatting-to-bytes-and-bytearray">% formatting to bytes and bytearray</h2>
<p><a href="https://www.python.org/dev/peps/pep-0461/">PEP 0461</a>: In Python 3, <code class="highlighter-rouge">bytes</code> became a new type completely separated from <code class="highlighter-rouge">str</code>. Some areas of computer programming work constantly with mixed binary and ASCII data, such as in network and systems development, so this new formatting allows <code class="highlighter-rouge">bytes</code> and <code class="highlighter-rouge">bytearray</code> to use the same % formatting that exists for strings.</p>

<p>Attention: numeric codes are automatically encoded in ASCII format. For instance:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="s">'</span><span class="si">%4</span><span class="s">x'</span> <span class="o">%</span> <span class="mi">10</span>
<span class="n">b</span><span class="s">'   a'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="s">'</span><span class="si">%04</span><span class="s">X'</span> <span class="o">%</span> <span class="mi">10</span>
<span class="s">'000A'</span></code></pre></figure>

<h2 id="-operator-for-matrix-multiplication">@ operator for matrix multiplication</h2>
<p><a href="https://www.python.org/dev/peps/pep-0465/">PEP 0465</a>: Numerical computation is an area where Python usage is growing day after day. In fact, packages such as <a href="http://www.numpy.org/"><code class="highlighter-rouge">numpy</code></a>, <a href="http://scikit-learn.org/"><code class="highlighter-rouge">scikit-learn</code></a>, and <a href="http://deeplearning.net/software/theano/"><code class="highlighter-rouge">theano</code></a> are <a href="https://www.python.org/dev/peps/pep-0465/#but-isn-t-matrix-multiplication-a-pretty-niche-requirement">some of the most used Python packages</a>, among standard and third-party packages.</p>

<p>Up to now, Python had only one multiplication operator - the star <code class="highlighter-rouge">*</code> - that has been used for two different purposes: element-wise and matrix multiplication. As we all know, duplication can lead to confusion and unreadable code, given that we always need to check how multiplication is implemented according to our data structures. Anyone who has written some numerical calculation in <a href="http://www.mathworks.com/products/matlab/">MATLAB</a> realized that the offering of two multiplication operators avoid this confusion: <code class="highlighter-rouge">*</code> stands for vector and matrix multiplication and <code class="highlighter-rouge">.*</code> is element-wise multiplication.</p>

<p>Historically, Python packages used the <code class="highlighter-rouge">*</code> operator for one kind of multiplication and a <code class="highlighter-rouge">dot</code> method for the other one. However, complex expressions with a large number of matrix multiplications suffer from poor syntax and need to the be split in several intermediary steps in order to preserve its legibility, <a href="http://refactoring.com/catalog/replaceTempWithChain.html">which is known as a code smell</a>.</p>

<p>By introducing the <code class="highlighter-rouge">@</code> operator for matrix multiplication, numerical calculations in Python have their legibility greatly improved. For instance, the following expressions, using <code class="highlighter-rouge">numpy</code>, are equivalent, except that the last one is much more readable.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">H</span> <span class="o">@</span> <span class="n">beta</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">inv</span><span class="p">(</span><span class="n">H</span> <span class="o">@</span> <span class="n">V</span> <span class="o">@</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">H</span> <span class="o">@</span> <span class="n">beta</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span></code></pre></figure>

<h2 id="isclosea-b">isclose(a, b)</h2>
<p><a href="https://www.python.org/dev/peps/pep-0485/">PEP 0485</a>: Still in the numeric computation realm, calculating whether a value is close enough to another value is extremely common. So common that a <code class="highlighter-rouge">isclose</code> method has just been added to the <code class="highlighter-rouge">math</code> module. This method also accepts a relative tolerance - the percentage in which <code class="highlighter-rouge">a</code> is considered to be close to <code class="highlighter-rouge">b</code> - or an absolute tolerance.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">10.000001</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">isclose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="bp">True</span></code></pre></figure>

<h2 id="coroutines-with-async-and-await">coroutines with async and await</h2>
<p><a href="https://www.python.org/dev/peps/pep-0492/">PEP 0492</a>: Concurrent programming is huge and trending since the industry demands responsive and scalable code. Although Python introduced some coroutines capabilities earlier, they shared their implementation with common generator expressions, the only difference being that coroutines used the <code class="highlighter-rouge">yield from</code> expression. This was unclear and error prone.</p>

<p>In Python 3.5.0, coroutines are introduced as a standalone concept, with their own syntax and low-level implementation. PEP 0492 provides the following example of coroutine with the new syntax.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">async</span> <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">db</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s">'SELECT ...'</span><span class="p">)</span>
    <span class="o">...</span></code></pre></figure>

<p>These are my favorite features in Python 3.5.0 and I will definitely update my version just to check them out and play with coroutines and matrix multiplication.</p>

<p>Tell me, what features have caught your eyes?</p>
:ET